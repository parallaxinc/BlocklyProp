<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>simpletools library: simpletools.h File Reference</title>
<link href="html/tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="html/doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">simpletools library
   &#160;<span id="projectnumber">v0.96.1</span>
   </div>
   <div id="projectbrief">Collection of convenience functions for common microcontroller tasks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="html/index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="html/files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="html/files.html"><span>File&#160;List</span></a></li>
      <li><a href="html/globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">simpletools.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library provides convenience functions for a variety of microcontroller I/O, timing, conversion, and communication tasks. This library also includes (and you can call functions from) <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20simpletext%20Library.html" target="blank">simpletext</a> and <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20serial%20Library.html" target="blank">serial</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;propeller.h&gt;</code><br/>
<code>#include &quot;simpletext.h&quot;</code><br/>
<code>#include &lt;driver.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;cog.h&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;dirent.h&gt;</code><br/>
<code>#include &lt;sys/sd.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &quot;simplei2c.h&quot;</code><br/>
</div>
<p><a href="html/simpletools_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a598a3330b3c21701223ee0ca14316eca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a598a3330b3c21701223ee0ca14316eca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI</b>&#160;&#160;&#160;3.141592653589793</td></tr>
<tr class="memitem:a95a8626764b7fcbf81fddaa0a197def8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a8626764b7fcbf81fddaa0a197def8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EEPROM_ADDR</b>&#160;&#160;&#160;0xA0 &gt;&gt; 1</td></tr>
<tr class="memitem:a0e26ea2db1b570d1a6fe1ac180ef4541"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e26ea2db1b570d1a6fe1ac180ef4541"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HOME</b>&#160;&#160;&#160;(1)</td></tr>
<tr class="memitem:afa53bcf09725cf1948b70eaaa229a3d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa53bcf09725cf1948b70eaaa229a3d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRSRXY</b>&#160;&#160;&#160;(2)</td></tr>
<tr class="memitem:a9e599685cbc5af2bb2a3baffdf881dff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e599685cbc5af2bb2a3baffdf881dff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRSRLF</b>&#160;&#160;&#160;(3)</td></tr>
<tr class="memitem:acaf84697e36358569284ae174db49051"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf84697e36358569284ae174db49051"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRSRRT</b>&#160;&#160;&#160;(4)</td></tr>
<tr class="memitem:a2fda2c79c6638bf0c75ce50209da388a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fda2c79c6638bf0c75ce50209da388a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRSRUP</b>&#160;&#160;&#160;(5)</td></tr>
<tr class="memitem:a01b2cacea568fc44982a68a31da8757f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01b2cacea568fc44982a68a31da8757f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRSRDN</b>&#160;&#160;&#160;(6)</td></tr>
<tr class="memitem:a1ceb0e81b845fdcd1b8371e92229a13b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ceb0e81b845fdcd1b8371e92229a13b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BEEP</b>&#160;&#160;&#160;(7)</td></tr>
<tr class="memitem:a4f41e5dc4d1d256277cb259077da1fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f41e5dc4d1d256277cb259077da1fc6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BKSP</b>&#160;&#160;&#160;(8)</td></tr>
<tr class="memitem:ad58a1fbfc85c7e4790fc55e654f50221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad58a1fbfc85c7e4790fc55e654f50221"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAB</b>&#160;&#160;&#160;(9)</td></tr>
<tr class="memitem:a4fc34b120ed3bd1120c1eb36abbcd6af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fc34b120ed3bd1120c1eb36abbcd6af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NL</b>&#160;&#160;&#160;(10)</td></tr>
<tr class="memitem:a350c9d6cb81908d59427ee96844d1a9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a350c9d6cb81908d59427ee96844d1a9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LF</b>&#160;&#160;&#160;(10)</td></tr>
<tr class="memitem:ac2f56dd6f32ebc7b504090212600d922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f56dd6f32ebc7b504090212600d922"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CLREOL</b>&#160;&#160;&#160;(11)</td></tr>
<tr class="memitem:a1cdb24d24f81764bea8c96fe07d48e0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cdb24d24f81764bea8c96fe07d48e0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CLRDN</b>&#160;&#160;&#160;(12)</td></tr>
<tr class="memitem:a876ce77f3c672c7162658151e648389e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a876ce77f3c672c7162658151e648389e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR</b>&#160;&#160;&#160;(13)</td></tr>
<tr class="memitem:a3cf3d7ff85aa894ae161d3f7ced308f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cf3d7ff85aa894ae161d3f7ced308f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRSRX</b>&#160;&#160;&#160;(14)</td></tr>
<tr class="memitem:af522fc6b22b3ec6d30fa9e5462d925e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af522fc6b22b3ec6d30fa9e5462d925e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRSRY</b>&#160;&#160;&#160;(15)</td></tr>
<tr class="memitem:ada59561816893aa39c4aa41f1043c554"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada59561816893aa39c4aa41f1043c554"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CLS</b>&#160;&#160;&#160;(16)</td></tr>
<tr class="memitem:a0a50888a81959bc58f01b49ec0f8c961"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a50888a81959bc58f01b49ec0f8c961"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSBPRE</b>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:acd0275a42546f7deb25aafca03ccadca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd0275a42546f7deb25aafca03ccadca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LSBPRE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:a08e82bb8e633953523a7b78de640174b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08e82bb8e633953523a7b78de640174b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSBPOST</b>&#160;&#160;&#160;2</td></tr>
<tr class="memitem:af55f183bf537941b4ef0b09655a560b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af55f183bf537941b4ef0b09655a560b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LSBPOST</b>&#160;&#160;&#160;3</td></tr>
<tr class="memitem:a5811613d98580676f67f0dde8125433e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5811613d98580676f67f0dde8125433e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LSBFIRST</b>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:a1c7ef42eff02618bde70868af4944d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c7ef42eff02618bde70868af4944d81"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSBFIRST</b>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:a4dbd6ec520f6a6b4e4610cc804c05fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dbd6ec520f6a6b4e4610cc804c05fe8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NCO_PWM_1</b>&#160;&#160;&#160;(0b00100 &lt;&lt; 26)</td></tr>
<tr class="memitem:af4f32a431c48e36da66f94897013ff09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4f32a431c48e36da66f94897013ff09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTR_NCO</b>&#160;&#160;&#160;(0b100 &lt;&lt; 26)</td></tr>
<tr class="memitem:a35343305570a7f0c402035a61ac54562"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35343305570a7f0c402035a61ac54562"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTR_PLL</b>&#160;&#160;&#160;(0b10 &lt;&lt; 26)</td></tr>
<tr class="memitem:a83e7c6583ebf1d8f9c2d2c32bbf0c984"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83e7c6583ebf1d8f9c2d2c32bbf0c984"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DUTY_SE</b>&#160;&#160;&#160;(0b110 &lt;&lt; 26)</td></tr>
<tr class="memitem:af9241e417ac6f468979cc60b0263d49f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#af9241e417ac6f468979cc60b0263d49f">pause_ticks</a>(pticks)&#160;&#160;&#160;__builtin_propeller_waitcnt(pticks+CNT, 0)</td></tr>
<tr class="memdesc:af9241e417ac6f468979cc60b0263d49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay cog from moving on to the next statement for a certain number of system clock ticks.  <a href="#af9241e417ac6f468979cc60b0263d49f"></a><br/></td></tr>
<tr class="memitem:ac04aea26e16ed3b740d27bc03eed2db5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac04aea26e16ed3b740d27bc03eed2db5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ac04aea26e16ed3b740d27bc03eed2db5">ee_put_byte</a>&#160;&#160;&#160;<a class="el" href="html/simpletools_8h.html#ae28b7b668cbb58c164a8259f403b8d60">ee_putByte</a></td></tr>
<tr class="memdesc:ac04aea26e16ed3b740d27bc03eed2db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_byte renamed ee_putByte. <br/></td></tr>
<tr class="memitem:aae4945cabc87fb08d37fca7e0db20422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae4945cabc87fb08d37fca7e0db20422"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#aae4945cabc87fb08d37fca7e0db20422">ee_get_byte</a>&#160;&#160;&#160;<a class="el" href="html/simpletools_8h.html#ac1042df969c1f5bffa816fdf068c4ed9">ee_getByte</a></td></tr>
<tr class="memdesc:aae4945cabc87fb08d37fca7e0db20422"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_get_byte renamed ee_getByte. <br/></td></tr>
<tr class="memitem:a1dd0c9e763b2c99590bde1206b8f49e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dd0c9e763b2c99590bde1206b8f49e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a1dd0c9e763b2c99590bde1206b8f49e0">ee_put_int</a>&#160;&#160;&#160;<a class="el" href="html/simpletools_8h.html#adf44a20755432a25076e28e94b809264">ee_putInt</a></td></tr>
<tr class="memdesc:a1dd0c9e763b2c99590bde1206b8f49e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_int renamed ee_putInt. <br/></td></tr>
<tr class="memitem:a6cbbc5e22a078c75b316d08fe6739509"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cbbc5e22a078c75b316d08fe6739509"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a6cbbc5e22a078c75b316d08fe6739509">ee_get_int</a>&#160;&#160;&#160;<a class="el" href="html/simpletools_8h.html#ad5ba1e74fdbc69a0578425eb5e176461">ee_getInt</a></td></tr>
<tr class="memdesc:a6cbbc5e22a078c75b316d08fe6739509"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_get_int renamed ee_getInt. <br/></td></tr>
<tr class="memitem:a59386353f20e5a9688e189423fbcfc85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59386353f20e5a9688e189423fbcfc85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a59386353f20e5a9688e189423fbcfc85">ee_put_str</a>&#160;&#160;&#160;<a class="el" href="html/simpletools_8h.html#ab958571c584ab8d846c3a8a2cb326109">ee_putStr</a></td></tr>
<tr class="memdesc:a59386353f20e5a9688e189423fbcfc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_str renamed ee_putStr. <br/></td></tr>
<tr class="memitem:a2c2ae1a4f7d1f422c346687845979b7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c2ae1a4f7d1f422c346687845979b7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a2c2ae1a4f7d1f422c346687845979b7f">ee_get_str</a>&#160;&#160;&#160;<a class="el" href="html/simpletools_8h.html#af70a2b4d4595f5cf5d60e9c585ca216d">ee_getStr</a></td></tr>
<tr class="memdesc:a2c2ae1a4f7d1f422c346687845979b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_get_str renamed ee_getStr. <br/></td></tr>
<tr class="memitem:a9d6e9570f4721c1a580299bdb80638d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d6e9570f4721c1a580299bdb80638d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a9d6e9570f4721c1a580299bdb80638d5">ee_put_float32</a>&#160;&#160;&#160;<a class="el" href="html/simpletools_8h.html#a10a9a5cd4767ffd7a82c9acd2b9485b2">ee_putFloat32</a></td></tr>
<tr class="memdesc:a9d6e9570f4721c1a580299bdb80638d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_float32 renamed ee_putFloat32. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4d9825708f3b6cae156e4e5f1e1647f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a4d9825708f3b6cae156e4e5f1e1647f6">high</a> (int pin)</td></tr>
<tr class="memdesc:a4d9825708f3b6cae156e4e5f1e1647f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to output-high.  <a href="#a4d9825708f3b6cae156e4e5f1e1647f6"></a><br/></td></tr>
<tr class="memitem:ab6b4677f42acfb2273127492d13a7e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ab6b4677f42acfb2273127492d13a7e05">low</a> (int pin)</td></tr>
<tr class="memdesc:ab6b4677f42acfb2273127492d13a7e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to output-low.  <a href="#ab6b4677f42acfb2273127492d13a7e05"></a><br/></td></tr>
<tr class="memitem:ac00aa846d252ba311694febd1100bd11"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ac00aa846d252ba311694febd1100bd11">toggle</a> (int pin)</td></tr>
<tr class="memdesc:ac00aa846d252ba311694febd1100bd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the output state of the I/O pin.  <a href="#ac00aa846d252ba311694febd1100bd11"></a><br/></td></tr>
<tr class="memitem:a2a78b7cb5f06e6fb893e78d2cfa36367"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a2a78b7cb5f06e6fb893e78d2cfa36367">input</a> (int pin)</td></tr>
<tr class="memdesc:a2a78b7cb5f06e6fb893e78d2cfa36367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to input.  <a href="#a2a78b7cb5f06e6fb893e78d2cfa36367"></a><br/></td></tr>
<tr class="memitem:abe4291907fc0563f65a1f3ed85fb878d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#abe4291907fc0563f65a1f3ed85fb878d">reverse</a> (int pin)</td></tr>
<tr class="memdesc:abe4291907fc0563f65a1f3ed85fb878d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the direction of an I/O pin.  <a href="#abe4291907fc0563f65a1f3ed85fb878d"></a><br/></td></tr>
<tr class="memitem:a9f77582253a5ee75241615296dcf0d05"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a9f77582253a5ee75241615296dcf0d05">get_state</a> (int pin)</td></tr>
<tr class="memdesc:a9f77582253a5ee75241615296dcf0d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the state of an I/O pin without setting it to input.  <a href="#a9f77582253a5ee75241615296dcf0d05"></a><br/></td></tr>
<tr class="memitem:aa3e6b702137ad730e834bce8a114a550"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#aa3e6b702137ad730e834bce8a114a550">get_direction</a> (int pin)</td></tr>
<tr class="memdesc:aa3e6b702137ad730e834bce8a114a550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the direction of the I/O pin.  <a href="#aa3e6b702137ad730e834bce8a114a550"></a><br/></td></tr>
<tr class="memitem:a1faf05ad4f74447ecbb557b4ee0c190e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a1faf05ad4f74447ecbb557b4ee0c190e">get_output</a> (int pin)</td></tr>
<tr class="memdesc:a1faf05ad4f74447ecbb557b4ee0c190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O pin output state.  <a href="#a1faf05ad4f74447ecbb557b4ee0c190e"></a><br/></td></tr>
<tr class="memitem:a97c13d6b776c998bd74286c6a8b774dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a97c13d6b776c998bd74286c6a8b774dd">set_direction</a> (int pin, int direction)</td></tr>
<tr class="memdesc:a97c13d6b776c998bd74286c6a8b774dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to a given direction.  <a href="#a97c13d6b776c998bd74286c6a8b774dd"></a><br/></td></tr>
<tr class="memitem:a016272b69e2e657a35621cfb815661d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a016272b69e2e657a35621cfb815661d3">set_output</a> (int pin, int state)</td></tr>
<tr class="memdesc:a016272b69e2e657a35621cfb815661d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I/O pin output register bit to either 1 or 0.  <a href="#a016272b69e2e657a35621cfb815661d3"></a><br/></td></tr>
<tr class="memitem:a9a59d35d804a8700b92e7637f55485c5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a9a59d35d804a8700b92e7637f55485c5">get_states</a> (int endPin, int startPin)</td></tr>
<tr class="memdesc:a9a59d35d804a8700b92e7637f55485c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get states of a contiguous group of I/O pins.  <a href="#a9a59d35d804a8700b92e7637f55485c5"></a><br/></td></tr>
<tr class="memitem:aef2876e81b935837260cf651cfeb0b0a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#aef2876e81b935837260cf651cfeb0b0a">get_directions</a> (int endPin, int startPin)</td></tr>
<tr class="memdesc:aef2876e81b935837260cf651cfeb0b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get directions for a contiguous group of I/O pins.  <a href="#aef2876e81b935837260cf651cfeb0b0a"></a><br/></td></tr>
<tr class="memitem:abf84ae3d77141e0787ac6322533aa5e2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#abf84ae3d77141e0787ac6322533aa5e2">get_outputs</a> (int endPin, int startPin)</td></tr>
<tr class="memdesc:abf84ae3d77141e0787ac6322533aa5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output settings for a contiguous group of I/O pins.  <a href="#abf84ae3d77141e0787ac6322533aa5e2"></a><br/></td></tr>
<tr class="memitem:aff22a28c433f3857ca116c5286ddab33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#aff22a28c433f3857ca116c5286ddab33">set_directions</a> (int endPin, int startPin, unsigned int pattern)</td></tr>
<tr class="memdesc:aff22a28c433f3857ca116c5286ddab33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set directions for a contiguous group of I/O pins.  <a href="#aff22a28c433f3857ca116c5286ddab33"></a><br/></td></tr>
<tr class="memitem:acbf5fe86eb36a02d4f86df2d3ca8d84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#acbf5fe86eb36a02d4f86df2d3ca8d84d">set_outputs</a> (int endPin, int startPin, unsigned int pattern)</td></tr>
<tr class="memdesc:acbf5fe86eb36a02d4f86df2d3ca8d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output states for a contiguous group of I/O pins.  <a href="#acbf5fe86eb36a02d4f86df2d3ca8d84d"></a><br/></td></tr>
<tr class="memitem:a381e2d58c3d6a1f0fd8129bcc4726804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a381e2d58c3d6a1f0fd8129bcc4726804">pause</a> (int time)</td></tr>
<tr class="memdesc:a381e2d58c3d6a1f0fd8129bcc4726804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay cog from moving on to the next statement for a certain length of time.  <a href="#a381e2d58c3d6a1f0fd8129bcc4726804"></a><br/></td></tr>
<tr class="memitem:afbfa1cfbdb01885472e3f64d26c09ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#afbfa1cfbdb01885472e3f64d26c09ed8">mark</a> (void)</td></tr>
<tr class="memdesc:afbfa1cfbdb01885472e3f64d26c09ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current time.  <a href="#afbfa1cfbdb01885472e3f64d26c09ed8"></a><br/></td></tr>
<tr class="memitem:aba16632261a1faa89b62c8d7d11b45cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#aba16632261a1faa89b62c8d7d11b45cc">timeout</a> (int time)</td></tr>
<tr class="memdesc:aba16632261a1faa89b62c8d7d11b45cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the time against the time elapsed since mark.  <a href="#aba16632261a1faa89b62c8d7d11b45cc"></a><br/></td></tr>
<tr class="memitem:a14f739412d16800b58f14029279e5332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a14f739412d16800b58f14029279e5332">wait</a> (int time)</td></tr>
<tr class="memdesc:a14f739412d16800b58f14029279e5332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits a certain number of time increments from the last call to mark or wait functions.  <a href="#a14f739412d16800b58f14029279e5332"></a><br/></td></tr>
<tr class="memitem:a04c171fd47bc9149c306576c349de680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a04c171fd47bc9149c306576c349de680">set_pause_dt</a> (int clockticks)</td></tr>
<tr class="memdesc:a04c171fd47bc9149c306576c349de680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set time increment for pause function.  <a href="#a04c171fd47bc9149c306576c349de680"></a><br/></td></tr>
<tr class="memitem:a20a9d97de9777b12cfd9353a83ac21cb"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a20a9d97de9777b12cfd9353a83ac21cb">count</a> (int pin, long duration)</td></tr>
<tr class="memdesc:a20a9d97de9777b12cfd9353a83ac21cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of low to high transitions an external input applies to an I/O pin over a certain period of time.  <a href="#a20a9d97de9777b12cfd9353a83ac21cb"></a><br/></td></tr>
<tr class="memitem:a7f87d0c6e5e644d9a2ad011e556de1e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a7f87d0c6e5e644d9a2ad011e556de1e8">dac_ctr</a> (int pin, int channel, int dacVal)</td></tr>
<tr class="memdesc:a7f87d0c6e5e644d9a2ad011e556de1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set D/A voltage.  <a href="#a7f87d0c6e5e644d9a2ad011e556de1e8"></a><br/></td></tr>
<tr class="memitem:af8ef60ed622a82bab16bea03cddc2340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#af8ef60ed622a82bab16bea03cddc2340">dac_ctr_res</a> (int bits)</td></tr>
<tr class="memdesc:af8ef60ed622a82bab16bea03cddc2340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set D/A voltage resolution.  <a href="#af8ef60ed622a82bab16bea03cddc2340"></a><br/></td></tr>
<tr class="memitem:a37edfbadb336de010e4cfdecdeca6148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a37edfbadb336de010e4cfdecdeca6148">dac_ctr_stop</a> (void)</td></tr>
<tr class="memdesc:a37edfbadb336de010e4cfdecdeca6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the cog that's transmitting the DAC signal(s).  <a href="#a37edfbadb336de010e4cfdecdeca6148"></a><br/></td></tr>
<tr class="memitem:a78d00871cfb358e7c1f4fea6fc5d07f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a78d00871cfb358e7c1f4fea6fc5d07f5">freqout</a> (int pin, int msTime, int frequency)</td></tr>
<tr class="memdesc:a78d00871cfb358e7c1f4fea6fc5d07f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use same cog to send square wave of a certain frequency for a certain amount of time. For set and forget with another cog, try square_wave function instead.  <a href="#a78d00871cfb358e7c1f4fea6fc5d07f5"></a><br/></td></tr>
<tr class="memitem:a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5">pwm_start</a> (unsigned int cycleMicroseconds)</td></tr>
<tr class="memdesc:a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start pulse width modulation (PWM) process in another cog.  <a href="#a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"></a><br/></td></tr>
<tr class="memitem:a57f683188c3dd35ee0574ff349835682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a57f683188c3dd35ee0574ff349835682">pwm_set</a> (int pin, int channel, int tHigh)</td></tr>
<tr class="memdesc:a57f683188c3dd35ee0574ff349835682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a PWM signal's high time.  <a href="#a57f683188c3dd35ee0574ff349835682"></a><br/></td></tr>
<tr class="memitem:aec8f4f09d7d0222e947bea4b37fc33c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#aec8f4f09d7d0222e947bea4b37fc33c2">pwm_stop</a> (void)</td></tr>
<tr class="memdesc:aec8f4f09d7d0222e947bea4b37fc33c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down PWM process and reclaim cog and I/O pins for other uses.  <a href="#aec8f4f09d7d0222e947bea4b37fc33c2"></a><br/></td></tr>
<tr class="memitem:ae251e0a94359068f5e56682311ef4201"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ae251e0a94359068f5e56682311ef4201">pulse_in</a> (int pin, int state)</td></tr>
<tr class="memdesc:ae251e0a94359068f5e56682311ef4201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the duration of a pulse applied to an I/O pin.  <a href="#ae251e0a94359068f5e56682311ef4201"></a><br/></td></tr>
<tr class="memitem:af7d62062bce6f1cb4bc03006f8463ba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#af7d62062bce6f1cb4bc03006f8463ba5">pulse_out</a> (int pin, int time)</td></tr>
<tr class="memdesc:af7d62062bce6f1cb4bc03006f8463ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a pulse with an I/O pin.  <a href="#af7d62062bce6f1cb4bc03006f8463ba5"></a><br/></td></tr>
<tr class="memitem:ad5f7522ca251c3cf3d7fd903fcdb5bbe"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ad5f7522ca251c3cf3d7fd903fcdb5bbe">rc_time</a> (int pin, int state)</td></tr>
<tr class="memdesc:ad5f7522ca251c3cf3d7fd903fcdb5bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I/O pin to input and measure the time it takes a signal to transition from a start state to the opposite state.  <a href="#ad5f7522ca251c3cf3d7fd903fcdb5bbe"></a><br/></td></tr>
<tr class="memitem:a521dea91cf2ba911ff66d3074672316f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a521dea91cf2ba911ff66d3074672316f">square_wave</a> (int pin, int channel, int freq)</td></tr>
<tr class="memdesc:a521dea91cf2ba911ff66d3074672316f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make I/O pin transmit a repeated high/low signal at a certain frequency. High and low times are the same. Frequency can range from 1 Hz to 128 MHz.  <a href="#a521dea91cf2ba911ff66d3074672316f"></a><br/></td></tr>
<tr class="memitem:a6291bd6f5b751420d414cff05e720ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a6291bd6f5b751420d414cff05e720ec8">square_wave_stop</a> (void)</td></tr>
<tr class="memdesc:a6291bd6f5b751420d414cff05e720ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the cog that's transmitting a square wave.  <a href="#a6291bd6f5b751420d414cff05e720ec8"></a><br/></td></tr>
<tr class="memitem:a288d762194e0bad67f4f37ba43f57292"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a288d762194e0bad67f4f37ba43f57292">set_io_timeout</a> (long clockTicks)</td></tr>
<tr class="memdesc:a288d762194e0bad67f4f37ba43f57292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout value for the following timed I/O functions: pulse_in, rc_time.  <a href="#a288d762194e0bad67f4f37ba43f57292"></a><br/></td></tr>
<tr class="memitem:ac4b081567b4d3d054382f88c777d740e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ac4b081567b4d3d054382f88c777d740e">set_io_dt</a> (long clockticks)</td></tr>
<tr class="memdesc:ac4b081567b4d3d054382f88c777d740e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time increment for the following timed I/O functions: count, pulse_in, pulse_out, rc_time.  <a href="#ac4b081567b4d3d054382f88c777d740e"></a><br/></td></tr>
<tr class="memitem:a4fca5193934cbc3b7fce7bfca131302d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a4fca5193934cbc3b7fce7bfca131302d">shift_in</a> (int pinDat, int pinClk, int mode, int bits)</td></tr>
<tr class="memdesc:a4fca5193934cbc3b7fce7bfca131302d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from a synchronous serial device.  <a href="#a4fca5193934cbc3b7fce7bfca131302d"></a><br/></td></tr>
<tr class="memitem:a39f6cd6c7f7965e057926f92a9b2fa29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a39f6cd6c7f7965e057926f92a9b2fa29">shift_out</a> (int pinDat, int pinClk, int mode, int bits, int value)</td></tr>
<tr class="memdesc:a39f6cd6c7f7965e057926f92a9b2fa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to a synchronous serial device.  <a href="#a39f6cd6c7f7965e057926f92a9b2fa29"></a><br/></td></tr>
<tr class="memitem:af029f9324f91d4d6deb9d20c0c787eff"><td class="memItemLeft" align="right" valign="top">i2c *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#af029f9324f91d4d6deb9d20c0c787eff">i2c_newbus</a> (int sclpin, int sdapin, int scldrive)</td></tr>
<tr class="memdesc:af029f9324f91d4d6deb9d20c0c787eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a simple serial driver with transmit &amp; receive pins.  <a href="#af029f9324f91d4d6deb9d20c0c787eff"></a><br/></td></tr>
<tr class="memitem:a8e388b4d227694772970f0ee51ad2c31"><td class="memItemLeft" align="right" valign="top">HUBTEXT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a8e388b4d227694772970f0ee51ad2c31">i2c_out</a> (i2c *bus, int i2cAddr, const unsigned char *regAddr, int regSize, const unsigned char *data, int <a class="el" href="html/simpletools_8h.html#a20a9d97de9777b12cfd9353a83ac21cb">count</a>)</td></tr>
<tr class="memdesc:a8e388b4d227694772970f0ee51ad2c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to device using I2C protocol.  <a href="#a8e388b4d227694772970f0ee51ad2c31"></a><br/></td></tr>
<tr class="memitem:a3716fa497e2d94ab9ab80c30b3109480"><td class="memItemLeft" align="right" valign="top">HUBTEXT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a3716fa497e2d94ab9ab80c30b3109480">i2c_in</a> (i2c *bus, int i2cAddr, const unsigned char *regAddr, int regSize, unsigned char *data, int <a class="el" href="html/simpletools_8h.html#a20a9d97de9777b12cfd9353a83ac21cb">count</a>)</td></tr>
<tr class="memdesc:a3716fa497e2d94ab9ab80c30b3109480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from device using I2C protocol.  <a href="#a3716fa497e2d94ab9ab80c30b3109480"></a><br/></td></tr>
<tr class="memitem:ae28b7b668cbb58c164a8259f403b8d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ae28b7b668cbb58c164a8259f403b8d60">ee_putByte</a> (char value, int addr)</td></tr>
<tr class="memdesc:ae28b7b668cbb58c164a8259f403b8d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a byte value at a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#ae28b7b668cbb58c164a8259f403b8d60"></a><br/></td></tr>
<tr class="memitem:ac1042df969c1f5bffa816fdf068c4ed9"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ac1042df969c1f5bffa816fdf068c4ed9">ee_getByte</a> (int addr)</td></tr>
<tr class="memdesc:ac1042df969c1f5bffa816fdf068c4ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte value from a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#ac1042df969c1f5bffa816fdf068c4ed9"></a><br/></td></tr>
<tr class="memitem:adf44a20755432a25076e28e94b809264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#adf44a20755432a25076e28e94b809264">ee_putInt</a> (int value, int addr)</td></tr>
<tr class="memdesc:adf44a20755432a25076e28e94b809264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an int value at a certain address in the Propeller Chip's dedicated EEPROM. An int value occupies four bytes, so the next value should be stored at an address value that's four bytes higher.  <a href="#adf44a20755432a25076e28e94b809264"></a><br/></td></tr>
<tr class="memitem:ad5ba1e74fdbc69a0578425eb5e176461"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ad5ba1e74fdbc69a0578425eb5e176461">ee_getInt</a> (int addr)</td></tr>
<tr class="memdesc:ad5ba1e74fdbc69a0578425eb5e176461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an int value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several int values, make sure to add 4 to the addr value with each successive call.  <a href="#ad5ba1e74fdbc69a0578425eb5e176461"></a><br/></td></tr>
<tr class="memitem:ab958571c584ab8d846c3a8a2cb326109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ab958571c584ab8d846c3a8a2cb326109">ee_putStr</a> (unsigned char *s, int n, int addr)</td></tr>
<tr class="memdesc:ab958571c584ab8d846c3a8a2cb326109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string of byte values starting at a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#ab958571c584ab8d846c3a8a2cb326109"></a><br/></td></tr>
<tr class="memitem:af70a2b4d4595f5cf5d60e9c585ca216d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#af70a2b4d4595f5cf5d60e9c585ca216d">ee_getStr</a> (unsigned char *s, int n, int addr)</td></tr>
<tr class="memdesc:af70a2b4d4595f5cf5d60e9c585ca216d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a string of byte values starting at a certain address in Propeller Chip's dedicated EEPROM.  <a href="#af70a2b4d4595f5cf5d60e9c585ca216d"></a><br/></td></tr>
<tr class="memitem:a10a9a5cd4767ffd7a82c9acd2b9485b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a10a9a5cd4767ffd7a82c9acd2b9485b2">ee_putFloat32</a> (float value, int addr)</td></tr>
<tr class="memdesc:a10a9a5cd4767ffd7a82c9acd2b9485b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a 32-bit precision floating point value at a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are storing values in a sequence, make sure to add 4 to each addr parameter value.  <a href="#a10a9a5cd4767ffd7a82c9acd2b9485b2"></a><br/></td></tr>
<tr class="memitem:a3da63e55d0799ab30686bf38a5f15d43"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a3da63e55d0799ab30686bf38a5f15d43">ee_getFloat32</a> (int addr)</td></tr>
<tr class="memdesc:a3da63e55d0799ab30686bf38a5f15d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a 32-bit precision floating point value from a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are fetching values in a sequence, make sure to add 4 to each addr parameter value.  <a href="#a3da63e55d0799ab30686bf38a5f15d43"></a><br/></td></tr>
<tr class="memitem:aa845f3e273a492072b625da584924f32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#aa845f3e273a492072b625da584924f32">sd_mount</a> (int doPin, int clkPin, int diPin, int csPin)</td></tr>
<tr class="memdesc:aa845f3e273a492072b625da584924f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount an SD card with the minimal 4-pin interface.  <a href="#aa845f3e273a492072b625da584924f32"></a><br/></td></tr>
<tr class="memitem:ace368f66ef489173117522773fa96eef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#ace368f66ef489173117522773fa96eef">itoa</a> (int i, char b[], int base)</td></tr>
<tr class="memdesc:ace368f66ef489173117522773fa96eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert value to zero terminated text string.  <a href="#ace368f66ef489173117522773fa96eef"></a><br/></td></tr>
<tr class="memitem:a61783ad70f65edb523f1f467bc47cabb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a61783ad70f65edb523f1f467bc47cabb">start_fpu_cog</a> (void)</td></tr>
<tr class="memdesc:a61783ad70f65edb523f1f467bc47cabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts floating point coprocessor (which runs in a separate cog) after it has been shut down by stop_fpu_cog. This process is started automatically when an application that uses the simpletools library is launched. So the only time you would call it is after calling stop_fpu_cog in order to reclaim a cog for other uses. CAUTION: Do not try call simpletext library functions while the fpu cog is shut down, it could cause the application to hang.  <a href="#a61783ad70f65edb523f1f467bc47cabb"></a><br/></td></tr>
<tr class="memitem:a736648757711b6d9b47073d860c8797d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/simpletools_8h.html#a736648757711b6d9b47073d860c8797d">stop_fpu_cog</a> (void)</td></tr>
<tr class="memdesc:a736648757711b6d9b47073d860c8797d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop floating point coprocessing cog that is started automatically when an application that uses the simpletools library is launched. When this function stops the cog running the floating point coprocessor, it will save a cog, but disable certain floating point functionalities until it is restarted by calling start_fpu_cog. CAUTION: Do not try call simpletext library functions while the fpu cog is shut down, it could cause the application to hang.  <a href="#a736648757711b6d9b47073d860c8797d"></a><br/></td></tr>
<tr class="memitem:ad0591fd1afec50de792bc2be9f283afa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0591fd1afec50de792bc2be9f283afa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>add_driver</b> (_Driver *driverAddr)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac918f387bafbf5be5ae048cecae7a873"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac918f387bafbf5be5ae048cecae7a873"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>iodt</b></td></tr>
<tr class="memitem:a47d0beb75b8f261c3690ffba50d5cda8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47d0beb75b8f261c3690ffba50d5cda8"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>t_timeout</b></td></tr>
<tr class="memitem:ac32bfd0f079f74e0b542acfe12858617"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac32bfd0f079f74e0b542acfe12858617"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>pauseTicks</b></td></tr>
<tr class="memitem:aae1cb6a158ee32bbdf3686eb12d96b46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae1cb6a158ee32bbdf3686eb12d96b46"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>t_mark</b></td></tr>
<tr class="memitem:a89441a99a19c5d6cbf367f4c10b22559"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89441a99a19c5d6cbf367f4c10b22559"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>setForget</b></td></tr>
<tr class="memitem:af28cb368c42f3dee1526424956728c01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af28cb368c42f3dee1526424956728c01"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fdserDriverIndex</b></td></tr>
<tr class="memitem:af4ec88c167cf4578da1ec0f46975f057"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ec88c167cf4578da1ec0f46975f057"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>buscnt</b></td></tr>
<tr class="memitem:a936f99bf236f37dfb6d132db8bcd0e2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a936f99bf236f37dfb6d132db8bcd0e2c"></a>
i2c *&#160;</td><td class="memItemRight" valign="bottom"><b>eeprom</b></td></tr>
<tr class="memitem:ae0aab7207c60d073c66e66a0a45117cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0aab7207c60d073c66e66a0a45117cd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>eeInitFlag</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This library provides convenience functions for a variety of microcontroller I/O, timing, conversion, and communication tasks. This library also includes (and you can call functions from) <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20simpletext%20Library.html" target="blank">simpletext</a> and <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20serial%20Library.html" target="blank">serial</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Andy Lindsay</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.96 (see details for more info)</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) Parallax, Inc. 2013. All Rights MIT Licensed.</dd></dl>
<p><b>NOTE:</b> If you want to update old projects to work with this version of simpletools, you may need to manually use the Add Simple Library button to add .../SimpleIDE/Learn/Text Devices/libsimpletext.</p>
<p><b><em>CONSTRUCTION ZONE:</em></b> This library is still preliminary, revisions pending. <br/>
 <br/>
 dac_ctr, square_wave, and all pwm functions, are currently only supported by the LMM and CMM memory models.</p>
<p>This (under development) library provides a set of introductory functions that simplify:</p>
<ul>
<li>I/O control - convenient I/O pin monitoring and control functions </li>
<li>Timing - Delays, timeouts </li>
<li>Timed I/O - pulse generation/measurement, square waves, transition counting, RC decay, etc. </li>
<li>Analog - D/A conversion, PWM, and more. <br/>
 For A/D conversion see ...Learn/Simple Libraries/Convert for A/D conversion libraries </li>
<li>Serial Communication - SPI, I2C <br/>
 For half and full duplex asynchronous serial communication, see ...Learn/Simple Libraries/Text Devices </li>
<li>Memory - EEPROM, SD storage</li>
</ul>
<p>Applications include: monitoring, control and communication with simple peripherals, like lights, buttons, dials, motors, peripheral integrated circuits and prototyping with simple systems that use pulse, or serial communication. (A few examples from the very large list of devices includes: servos, ultrasonic distance sensors, accelerometers, serial liquid crystal, display, etc.)</p>
<p>Intended use: Accompanies introductory electronics, robotics and programming lessons and projects on learn.parallax.com. After these lessons, bridge lessons will be added to familiarize the programmer with standard practices used by the community for adding libraries to support and endless variety of peripherals and applications.</p>
<p>Revision 0.91 shift_in function pre-clock mode bug fixed. <br/>
 <br/>
 Revision 0.92 Simpletext functionality incorporated for use of character and string I/O with both terminal and peripheral devices. Simple Text folder replaces PropGCC serial driver support for simple and full duplex serial peripherals. <br/>
 <br/>
 Revision 0.93 i2c_newbus now uses <br/>
 .../Learn/Simple Libraries/Protocol/simplei2c/<br/>
 Added:<br/>
 i2c_out, i2c_in to cover most common I2C slave applications EEPROM ee_get_* and ee_put_* changed to ee_get* and ee_put* where the * term is camel-case. <br/>
 <br/>
 Revision 0.94 Fixed bug in ee_put* that prevented contiguous data from crossing the EEPROM's address/128 buffer boundaries. Updated stack array to static in mstimer.c.<br/>
<br/>
 Revision 0.95 square_wave bug that prevented output frequency changes (fixed). <br/>
<br/>
 Revision 0.96 ee_putStr updated to support 128 byte page writes. More corrections to ee_put* for contiguous data crossing address/128 boundary. Revision 0.96.1 Add documentation for start_fpu_cog and stop_fpu_cog. </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="af9241e417ac6f468979cc60b0263d49f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pause_ticks</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pticks</td><td>)</td>
          <td>&#160;&#160;&#160;__builtin_propeller_waitcnt(pticks+CNT, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay cog from moving on to the next statement for a certain number of system clock ticks. </p>
<p>At 80 MHz, each clock tick is 12.5 ns. Code overhead varies depending on memory model and optimization. A simple test if you want a certain number of clock ticks is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ti, tf, us, pauseTicks;</div>
<div class="line">us = CLKFREQ/1000000;                               <span class="comment">// 1 us worth of ticks</span></div>
<div class="line">pauseTicks = 50*us;                                 <span class="comment">// 50 us of ticks</span></div>
<div class="line">ti = CNT;                                           <span class="comment">// Save start time</span></div>
<div class="line"><a class="code" href="html/simpletools_8h.html#af9241e417ac6f468979cc60b0263d49f" title="Delay cog from moving on to the next statement for a certain number of system clock ticks...">pause_ticks</a>(pauseTicks);                            <span class="comment">// Call pause_ticks</span></div>
<div class="line">tf = CNT;                                           <span class="comment">// Save end time</span></div>
<div class="line">printf(<span class="stringliteral">&quot;pauseTicks = %d\n&quot;</span>, pauseTicks);            <span class="comment">// Display pauseTicks</span></div>
<div class="line">printf(<span class="stringliteral">&quot;delayTicks = %d\n&quot;</span>, tf - ti);               <span class="comment">// Display measured</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pticks</td><td>the number of pause clock ticks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a20a9d97de9777b12cfd9353a83ac21cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long count </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of low to high transitions an external input applies to an I/O pin over a certain period of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number </td></tr>
    <tr><td class="paramname">duration</td><td>Amount of time the measurement counts transitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of low to high transitions </dd></dl>

</div>
</div>
<a class="anchor" id="a7f87d0c6e5e644d9a2ad011e556de1e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dac_ctr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dacVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set D/A voltage. </p>
<p>Launches process into another cog for up to two channels of D/A conversion on any I/O pin. Other libraries may be available that provide D/A for more channels. Check SimpleIDE/Learn/Simple Libraries/Convert for options. For more options, check obex.parallax.com.</p>
<p>This library uses another cog's counter modules (2 per cog) to perform duty modulation, which is useful for D/A conversion. The digital signal it generates will affect LED brightness. The signal can be passed through a low pass RC filter for digital to analog voltage conversion. Add an op amp buffer if it needs to drive a load.</p>
<p>Default resolution is 8 bits for output voltages ranging from 0 V to (255/256) of 3.3 V.</p>
<p>General equation is dacVal * (3.3 V/2^bits)</p>
<p>Default is 8 bits, which results in dacVal * (3.3 V/ 256), so dacVal specifies the number of 256ths of 3.3 V. You can change the resolution with the dac_ctr_res function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">channel</td><td>Use 0 or 1 to select the cog's CTRA or CTRB counter modules, which are used for D/A conversion. </td></tr>
    <tr><td class="paramname">dacVal</td><td>Number of 256ths of 3.3 V by default. Use a value from 0 (0 V) to 255 . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8ef60ed622a82bab16bea03cddc2340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dac_ctr_res </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set D/A voltage resolution. </p>
<p>Default resolution is 8-bits for output voltages ranging from 0 V to (255/256) of 3.3 V.</p>
<p>General equation is dacVal * (3.3 V/2^bits)</p>
<p>Default is 8 bits, which results in dacVal * (3.3 V/ 256), so dacVal specifies the number of 256ths of 3.3 V.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>The D/A converter's resolution in bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37edfbadb336de010e4cfdecdeca6148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dac_ctr_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the cog that's transmitting the DAC signal(s). </p>
<p>Stops any signals, lets go of any I/O pins, and reclaims the cog for other uses. </p>

</div>
</div>
<a class="anchor" id="ac1042df969c1f5bffa816fdf068c4ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ee_getByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte value from a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address that with the byte value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The byte value stored by the EEPROM at the address specified by the addr parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a3da63e55d0799ab30686bf38a5f15d43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ee_getFloat32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a 32-bit precision floating point value from a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are fetching values in a sequence, make sure to add 4 to each addr parameter value. </p>
<p>Make sure that the Math box is checked in the Project Manger. In Simple View, click the Show Project Manager button in SimpleIDE's bottom-left corner. Then click the Linker tab, and check the Math Lib box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address with the 32-bit floating point float value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The float value stored by the EEPROM at the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5ba1e74fdbc69a0578425eb5e176461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ee_getInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an int value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several int values, make sure to add 4 to the addr value with each successive call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address with the int value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The int value stored by the EEPROM at the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="af70a2b4d4595f5cf5d60e9c585ca216d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ee_getStr </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a string of byte values starting at a certain address in Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Address of a char array to receive the string of bytes fetched from EEPROM.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy from EEPROM to the array.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address of the first byte in the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the array that stores the characters that were fetched. </dd></dl>

</div>
</div>
<a class="anchor" id="ae28b7b668cbb58c164a8259f403b8d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putByte </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a byte value at a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The byte value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10a9a5cd4767ffd7a82c9acd2b9485b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putFloat32 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a 32-bit precision floating point value at a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are storing values in a sequence, make sure to add 4 to each addr parameter value. </p>
<p>Make sure that the Math box is checked in the Project Manger. In Simple View, click the Show Project Manager button in SimpleIDE's bottom-left corner. Then click the Linker tab, and check the Math Lib box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 32-bit floating point float value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf44a20755432a25076e28e94b809264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store an int value at a certain address in the Propeller Chip's dedicated EEPROM. An int value occupies four bytes, so the next value should be stored at an address value that's four bytes higher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The int value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab958571c584ab8d846c3a8a2cb326109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putStr </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a string of byte values starting at a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Address of a char array containing the string of bytes.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy from the array.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address of the first byte in the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78d00871cfb358e7c1f4fea6fc5d07f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freqout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use same cog to send square wave of a certain frequency for a certain amount of time. For set and forget with another cog, try square_wave function instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin that sends the frequency </td></tr>
    <tr><td class="paramname">msTime</td><td>Time in ms that the signal lasts </td></tr>
    <tr><td class="paramname">frequency</td><td>Frequency of the signal in Hz. Accepts values from 1 Hz to 128000000 Hz (128 MHz). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3e6b702137ad730e834bce8a114a550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_direction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the direction of the I/O pin. </p>
<p>This function will tell you the direction of the I/O pin as seen by the cog executing it. Keep in mind that that your program might make other cogs use the I/O pin as an output, and a cog that treats a pin as an output wins over one that treats it as an input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I/O pin direction as seen by the cog that runs the function. </dd></dl>

</div>
</div>
<a class="anchor" id="aef2876e81b935837260cf651cfeb0b0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_directions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get directions for a contiguous group of I/O pins. </p>
<p>Get direction register states from a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>States value containing a binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="a1faf05ad4f74447ecbb557b4ee0c190e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_output </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O pin output state. </p>
<p>Keep in mind that this function reports the value in the output register for the cog running the function. That doesn't tell you if the I/O pin is set to input, or whether another cog is sending a different output state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In a register bit for I/O pin, either 1 or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="abf84ae3d77141e0787ac6322533aa5e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_outputs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get output settings for a contiguous group of I/O pins. </p>
<p>Get output register settings for a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pattern value containing a binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f77582253a5ee75241615296dcf0d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the state of an I/O pin without setting it to input. </p>
<p>Use this function instead of input if the Propeller needs to maintain an output. For example, you can use this to monitor another cog's or counter's output signal activity on a pin. (Note: if the pin is already set to input, it will return the state the external circuit is applying, just like input.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pin's state. If the pin is an output, 1 = 3.3 V and 0 = 0 V. If the pin is an input, 1 means V &gt; 1.65 V, 0 means it's less. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a59d35d804a8700b92e7637f55485c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_states </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get states of a contiguous group of I/O pins. </p>
<p>This works the same as getState, but for a group of pins. It tells you the actual state of each pin, regardless of whether it's a voltage applied to input or transmitted by an output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>States value containing the binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d9825708f3b6cae156e4e5f1e1647f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void high </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to output-high. </p>
<p>This function set makes the Propeller P8X32A connect the I/O pin to its positive 3.3 V supply voltage enabling it to source up to 40 mA of current (max 1 W dissipation per chip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin to set high. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3716fa497e2d94ab9ab80c30b3109480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HUBTEXT int i2c_in </td>
          <td>(</td>
          <td class="paramtype">i2c *&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2cAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from device using I2C protocol. </p>
<p>This function uses Simple Libraries/Protocol/libsimplei2c for clock and data line signaling. You can also use this library to create custom I2C functions. Other I2C signaling options are included in Propeller GCC. Search for i2C int he propgcc folder for more info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*bus</td><td>pointer to an I2C bus. Use i2c_newbus to get a pointer to an I2C bus structure.</td></tr>
    <tr><td class="paramname">i2cAddr</td><td>8 bit device address. This is the 7-bit I2C address and read/write bit. The value of the read/write bit does not matter because the i2c_out and i2c_in functions clear and set it as needed.</td></tr>
    <tr><td class="paramname">regAddr</td><td>Pointer to variable or array that contains the number of bytes to write to the device's register(s) or a memory address.</td></tr>
    <tr><td class="paramname">regSize</td><td>Number of bytes to use for regAddr. This value can be zero for no register or memory address data.</td></tr>
    <tr><td class="paramname">*data</td><td>Pointer to variable or array that will receive data from I2C device.</td></tr>
    <tr><td class="paramname">count</td><td>number of bytes in data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total number of bytes written. Should be 1 + regSize + count. </dd></dl>

</div>
</div>
<a class="anchor" id="af029f9324f91d4d6deb9d20c0c787eff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c* i2c_newbus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sclpin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdapin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scldrive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a simple serial driver with transmit &amp; receive pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sclpin</td><td>the I2C bus' serial clock pin.</td></tr>
    <tr><td class="paramname">sdapin</td><td>the I2C bus' serial data pin.</td></tr>
    <tr><td class="paramname">scldrive</td><td>sets I/O pin connected to SCL line to send high signals by either (sclDrive = 0) allowing the pullup resistor on the bus to pull the line high, or (sclDrive = 1) by setting the I/O pin to output and driving the line high. sclDrive = 0 is by far the most common arrangement. sclDrive = 1 is used with some Propeller boards that do not have a pull-up resistor on the EEPROM's SCL line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I2C bus. You will need this to pass to the i2cWrite and i2cRead functions for communication on the bus. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e388b4d227694772970f0ee51ad2c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HUBTEXT int i2c_out </td>
          <td>(</td>
          <td class="paramtype">i2c *&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2cAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to device using I2C protocol. </p>
<p>This function uses Simple Libraries/Protocol/libsimplei2c for clock and data line signaling. You can also use this library to create custom I2C functions. Other I2C signaling options are included in Propeller GCC. Search for i2C int he propgcc folder for more info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*bus</td><td>pointer to an I2C bus. Use i2c_newbus to get a pointer to an I2C bus structure.</td></tr>
    <tr><td class="paramname">i2cAddr</td><td>8 bit device address. This is the 7-bit I2C address and read/write bit. The value of the read/write bit does not matter because the i2c_out and i2c_in functions clear and set it as needed.</td></tr>
    <tr><td class="paramname">*regAddr</td><td>Pointer to variable or array that contains the number of bytes to write to the device's register(s) or a memory address.</td></tr>
    <tr><td class="paramname">regSize</td><td>Number of bytes to use for regAddr. This value can be zero for no register or memory address data.</td></tr>
    <tr><td class="paramname">*data</td><td>Pointer to variable or array to send to the I2C device.</td></tr>
    <tr><td class="paramname">count</td><td>number of bytes in data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total number of bytes written. Should be 1 + regSize + count. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a78b7cb5f06e6fb893e78d2cfa36367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to input. </p>
<p>This function makes the Propeller connect the I/O pin to its input buffer so that it can return the binary value of the voltage applied by an external circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin to set to input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 or 0 to indicate high or low signal received. </dd></dl>

</div>
</div>
<a class="anchor" id="ace368f66ef489173117522773fa96eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* itoa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>b</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert value to zero terminated text string. </p>
<p>Given an int, a character array pointer and a base, this function converts the int into the characters that represent the value in the specified base.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>An integer value. </td></tr>
    <tr><td class="paramname">b[]</td><td>A character array pointer. </td></tr>
    <tr><td class="paramname">base</td><td>The number base for the character representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character array address it received. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6b4677f42acfb2273127492d13a7e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void low </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to output-low. </p>
<p>This function makes the Propeller P8X32A connect the I/O pin to its ground 0 V supply voltage enabling it to sink up to 40 mA of current (max 1 W dissipation per chip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin to set low. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbfa1cfbdb01885472e3f64d26c09ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the current time. </p>
<p>The timeout function uses the marked time to determine if a timeout has occurred. </p>

</div>
</div>
<a class="anchor" id="a381e2d58c3d6a1f0fd8129bcc4726804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pause </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay cog from moving on to the next statement for a certain length of time. </p>
<p>The default time increment is 1 ms, so pause(100) would delay for 100 ms = 1/10th of a second. This time increment can be changed with a call to the set_pause_dt function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The number of time increments to delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae251e0a94359068f5e56682311ef4201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long pulse_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the duration of a pulse applied to an I/O pin. </p>
<p>Default time increments are specified in 1 microsecond units. Unit size can be changed with a call to set_io_dt function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number </td></tr>
    <tr><td class="paramname">state</td><td>State of the pulse (1 for positive or high pulses, 0 for negative or low pulses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of time units the pulse lasted. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d62062bce6f1cb4bc03006f8463ba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pulse_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a pulse with an I/O pin. </p>
<p>Default time increments are specified in 1 microsecond units. Unit size can be changed with a call to set_io_dt function. The pulse will be positive if the I/O pin is transmitting a low signal before the call. The pulse will be negative if it transmits a high signal before the call. When the pulse is done, the pin returns to whatever state it was in before the pulse. If the pin was an input, it will be changed to output and use whatever value was in the output register bit for the pin. This defaults to low on startup, but you can pre-set it while leaving the pin set to input with the set_output function (or check it with get_output).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">time</td><td>Amount of time the pulse lasts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57f683188c3dd35ee0574ff349835682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pwm_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tHigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a PWM signal's high time. </p>
<p>After a single call to pwm_start, this function allows you to set a PWM signal's high time. For example, if your pwm_start call sets up 1000 us (1 ms) you could use this function to make the signal high for 3/4 of its cycle with pwm_set(pin, channel, 750). If the signal goes to a DC motor through an H bridge or other driver circuit, the motor will behave as though it's only getting 3/4 of the supply and turn at roughly 3/4 of full speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin to send the PWM signal. You can change this value on the fly, which is useful for speed control of a DC motor in two different directions. When the PWM signal changes to a new pin, the cog sets the previous pin to input. If you want it to stay low when the PWM cog lets go, just set the pin low in your code before calling pwm_start.</td></tr>
    <tr><td class="paramname">channel</td><td>You have options of 0 or 1 for up to two simultaneous PWM signals. If you have an application in mind that requires more PWM signals, check the SimpleIDE/Learn/Simple Libraries/Motor directory, and also online at obex.parallax.com.</td></tr>
    <tr><td class="paramname">tHigh</td><td>The high time for each PWM cycle repetition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pwm_start </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycleMicroseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start pulse width modulation (PWM) process in another cog. </p>
<p>Great for DC motors, can also be used for servos, but the servo library is probably a better choice for that.</p>
<p>A PWM signal sends repeated high signals with a fixed cycle time. Your code will typically control the amount of time a PWM signal is high during each cycle. For example, pwm_start(1000) will establish a 1000 us PWM cycle. You can then use the pwm_set function to send high signals that last anywhere from 0 to 1000 us.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycleMicroseconds</td><td>Number of microseconds the PWM cycle lasts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec8f4f09d7d0222e947bea4b37fc33c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pwm_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down PWM process and reclaim cog and I/O pins for other uses. </p>
<p>Shut down PWM process and reclaim cog and I/O pins for other uses </p>

</div>
</div>
<a class="anchor" id="ad5f7522ca251c3cf3d7fd903fcdb5bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long rc_time </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I/O pin to input and measure the time it takes a signal to transition from a start state to the opposite state. </p>
<p>Named rc_time because it is often used to measure a resistor-capacitor circuit's tendency to "decay" to either ground or 5 V (depending on wiring). Default time increments are specified in 1 microsecond units. Unit size can be changed with a call to set_io_dt function. The pulse will be positive if the I/O pin is transmitting a low signal before the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">state</td><td>Starting pin state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time from starting pin. </dd></dl>

</div>
</div>
<a class="anchor" id="abe4291907fc0563f65a1f3ed85fb878d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int reverse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the direction of an I/O pin. </p>
<p>If an I/O pin's direction is set to input, this function changes it to output. If it's set to output, this function changes it to input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pin direction. </dd></dl>

</div>
</div>
<a class="anchor" id="aa845f3e273a492072b625da584924f32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sd_mount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>doPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clkPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>csPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount an SD card with the minimal 4-pin interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doPin</td><td>The SD card's data out pin.</td></tr>
    <tr><td class="paramname">clkPin</td><td>The SD card's clock pin.</td></tr>
    <tr><td class="paramname">diPin</td><td>The SD card's data in pin.</td></tr>
    <tr><td class="paramname">csPin</td><td>The SD card's chip select pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status 0 if successful, or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a97c13d6b776c998bd74286c6a8b774dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_direction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to a given direction. </p>
<p>This function sets an I/O pin to either output or input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">direction</td><td>I/O pin direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff22a28c433f3857ca116c5286ddab33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_directions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set directions for a contiguous group of I/O pins. </p>
<p>Set directions values in a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin. </td></tr>
    <tr><td class="paramname">pattern</td><td>Value containing the binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4b081567b4d3d054382f88c777d740e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_io_dt </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>clockticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time increment for the following timed I/O functions: count, pulse_in, pulse_out, rc_time. </p>
<p>Time increment is set in clock ticks. For example, the default of 1 us units is specified with set_io_dt(CLKFREQ/1000000). For 2 microsecond units, use set_io_dt(CLKFREQ/500000).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clockticks</td><td>Number of clocktics that represents one I/O time increment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a288d762194e0bad67f4f37ba43f57292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_io_timeout </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>clockTicks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timeout value for the following timed I/O functions: pulse_in, rc_time. </p>
<p>Time increment is set in clock ticks. For example, the default of 0.25 seconds is set with set_io_timeout(CLKFREQ/4). To set the timeout to 20 ms, you could use set_io_timeout(CLKFREQ/50).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clockTicks</td><td>Number of clock ticks for timed I/O </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a016272b69e2e657a35621cfb815661d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_output </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I/O pin output register bit to either 1 or 0. </p>
<p>This function focuses on the I/O pin's output register. If you intend to use it to send high or low signals, consider using high or low functions. This function can also be used in conjunction with set_direction to send high or low signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin to set high or low. </td></tr>
    <tr><td class="paramname">state</td><td>1 for high, 0 for low (when pin is actually set to output, which can be done with setDirection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbf5fe86eb36a02d4f86df2d3ca8d84d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_outputs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output states for a contiguous group of I/O pins. </p>
<p>Set output states of a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin. </td></tr>
    <tr><td class="paramname">pattern</td><td>Value containing the binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04c171fd47bc9149c306576c349de680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_pause_dt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clockticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set time increment for pause function. </p>
<p>Default time increment for pause function is 1 ms. This function allows you to change that delay to custom values. For example, set_pause_dt(CLKFREQ/2000) would set it to 1/2 ms increments. To return to default 1 ms increments, use set_pause_dt(CLKFREQ/1000).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clockticks</td><td>the number of clock ticks that pause(1) will delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fca5193934cbc3b7fce7bfca131302d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shift_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from a synchronous serial device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDat</td><td>Data pin. </td></tr>
    <tr><td class="paramname">pinClk</td><td>Clock pin. </td></tr>
    <tr><td class="paramname">mode</td><td>Order and orientation to clock pulse options: MSBPRE, LSBPRE, MSBPOST,LSBPOST. </td></tr>
    <tr><td class="paramname">bits</td><td>Number of binary values to transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value received from the synchronous serial device. </dd></dl>

</div>
</div>
<a class="anchor" id="a39f6cd6c7f7965e057926f92a9b2fa29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shift_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to a synchronous serial device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDat</td><td>Data pin </td></tr>
    <tr><td class="paramname">pinClk</td><td>Clock pin </td></tr>
    <tr><td class="paramname">mode</td><td>Order that bits are transmitteed, either LSBFIRST or MSBFIRST. </td></tr>
    <tr><td class="paramname">bits</td><td>Number of binary values to transfer. </td></tr>
    <tr><td class="paramname">value</td><td>to transmit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a521dea91cf2ba911ff66d3074672316f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void square_wave </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make I/O pin transmit a repeated high/low signal at a certain frequency. High and low times are the same. Frequency can range from 1 Hz to 128 MHz. </p>
<p>Uses one additional cog with up to two active channels, each with a selectable frequency. You can change transmit pins on the fly by calling this function on the same channel, but with a different pin. The previous pin will be set to input in that cog. If your code is set to output, it will not affect that setting, only the setting for the cog that is transmitting the square wave. Code in your cog, or some other cog can modulate the signal. A low signal allows the square wave to transmit, and a high signal prevents it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin that transmits square wave frequency. To stop sending the signal. and change the pin back to input, pass the pin as a negative number. </td></tr>
    <tr><td class="paramname">channel</td><td>0 or 1 selects the counter module to transmit the frequency. </td></tr>
    <tr><td class="paramname">freq</td><td>Square wave frequency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6291bd6f5b751420d414cff05e720ec8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void square_wave_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the cog that's transmitting a square wave. </p>
<p>Stops any signals, lets go of any I/O pins, and reclaims the cog for other uses. </p>

</div>
</div>
<a class="anchor" id="a61783ad70f65edb523f1f467bc47cabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int start_fpu_cog </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts floating point coprocessor (which runs in a separate cog) after it has been shut down by stop_fpu_cog. This process is started automatically when an application that uses the simpletools library is launched. So the only time you would call it is after calling stop_fpu_cog in order to reclaim a cog for other uses. CAUTION: Do not try call simpletext library functions while the fpu cog is shut down, it could cause the application to hang. </p>
<dl class="section return"><dt>Returns</dt><dd>Nonzero if successful, or zero if no cogs available. </dd></dl>

</div>
</div>
<a class="anchor" id="a736648757711b6d9b47073d860c8797d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop_fpu_cog </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop floating point coprocessing cog that is started automatically when an application that uses the simpletools library is launched. When this function stops the cog running the floating point coprocessor, it will save a cog, but disable certain floating point functionalities until it is restarted by calling start_fpu_cog. CAUTION: Do not try call simpletext library functions while the fpu cog is shut down, it could cause the application to hang. </p>
<dl class="section return"><dt>Returns</dt><dd>Nonzero if successful, or zero if no cogs available. </dd></dl>

</div>
</div>
<a class="anchor" id="aba16632261a1faa89b62c8d7d11b45cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int timeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the time against the time elapsed since mark. </p>
<p>The default time increment is 1 us, so timeout(2000) will return 1 if 2 ms or more has elapsed since mark, or 0 if it has not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Number of time increments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac00aa846d252ba311694febd1100bd11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int toggle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the output state of the I/O pin. </p>
<p>Change I/O pin's output state from low to high or high to low. This function assumes that some other function has already set the I/O pin to output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pin state. </dd></dl>

</div>
</div>
<a class="anchor" id="a14f739412d16800b58f14029279e5332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits a certain number of time increments from the last call to mark or wait functions. </p>
<p>The default time increment is 1 us, so wait(2000) will return wait until 2 us after the last call to mark or wait. This function automatically updates the marked time; you can call it repeatedly without having to call mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Number of time increments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 6 2013 18:04:30 for simpletools library by &#160;<a href="html/http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
